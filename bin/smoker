#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2015-2018, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# I Love App::SmokeBox::Mini, unfortunately too many of its dependancies don't
# build on many platforms, so this is a small plaything that does for me

# Takes an optional argument of the number of minutes since the last run

# 19 * * * * [ -r .perlbrew/init ] && /bin/bash bin/perlbrew-cron bin/smoker 60

use warnings;
use strict;
# use autodie qw(:all);

use Getopt::Std;
use LWP::Simple;
use File::HomeDir;
use File::Spec;
use File::Basename;
use Fcntl qw(:flock);
use BSD::Resource;
use Unix::Processors;
# use Sys::LoadAvg;	# Core dumps because the array isn't big enough. Bug report has been ignored
use Sys::CpuLoad;
use POSIX ":sys_wait_h";
use IO::Handle;
use lib File::Spec->catfile(File::HomeDir->my_home(), '/.cpan/CPAN');
use IPC::Cmd;
use Config;

use MyConfig;

my $mode;

# Work out the best way to run commands
if($Config{'osname'} eq 'solaris') {
	# Work around /usr/lib being built with Sun's C compiler, so
	# less is available because of link handshake errors
	eval {
		# Needs Proc::Processtable which doesn't support DragonflyBSD
		require Proc::Killfam;
		Proc::Killfam->import();
		$mode = 'killfam';
	};
	if(!defined($mode)) {
		eval {
			# Doesn't needs at least Perl 5.10.0
			require Proc::Govern;
			Proc::Govern->import();
			$mode = 'govern';
		};
	}
	if(!defined($mode)) {
		require IPC::Cmd;
		IPC::Cmd->import();
		$mode = 'cmd';
	}
} elsif($Config{'osname'} ne 'dragonfly') {
        # Needs Proc::Processtable which doesn't support DragonflyBSD
        require Proc::Killfam;
        Proc::Killfam->import();
        $mode = 'killfam';
} elsif(defined($^V) && ($^V ge 'v5.10.1')) {
        # Doesn't needs at least Perl 5.10.1
        require Proc::Govern;
        Proc::Govern->import();
        $mode = 'govern';
} else {
        require IPC::Cmd;
        IPC::Cmd->import();
        $mode = 'cmd';
}

die 'Install and configure CPAN::Reporter' unless($CPAN::Config->{'test_report'});
die unless($CPAN::Config->{'urllist'});

my %opts;
getopts('iv', \%opts);

print "Mode: $mode\n" if($opts{'v'});

my $recent;
foreach my $url(@{$CPAN::Config->{'urllist'}}) {
	$recent = get("$url/RECENT");
	if($recent) {
		print "Fetching from $url\n" if($opts{'v'});
		last;
	}
}

die if(!$recent);

$ENV{'CPAN_SQLITE_NO_LOG_FILES'} = 1;
delete $ENV{'CC'};
delete $ENV{'CFLAGS'};
delete $ENV{'LDFLAGS'};
if(!$opts{'i'}) {
	$ENV{'AUTOMATED_TESTING'} = 1;
}

my $lockfile = File::Spec->catfile($CPAN::Config->{'cpan_home'}, '.lock');
if((-r $lockfile) && (open(my $lock, '<', $lockfile))) {
	my $pid = <$lock>;
	close $lock;
	chomp $pid;
	if(kill(0, $pid)) {
		print "CPAN shell running\n";
		exit;
	}
	unlink $lockfile;
}
$lockfile = File::Spec->catfile(File::Spec->tmpdir(), 'cpan-test.lck');

local $SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub {
	unlink $lockfile;
	exit 1;
};

# setrlimit(RLIMIT_DATA, 32 * 1024 * 1024, 64 * 1024 * 1024) or
	# warn ('Can\'t limit the data size - watch for memory usage');

# setrlimit(RLIMIT_RSS, 32 * 1024 * 1024, 64 * 1024 * 1024) or
	# warn ('Can\'t limit the data size - watch for memory usage');

setrlimit(RLIMIT_CPU, 3300, 3600) or
	warn ('Can\'t limit the CPU time - watch for long running programs');

# Eval added to handle RT113898
# eval {
	# my $number_of_cpus = Sys::Info->new()->device('CPU')->count();
#
	# if(defined($number_of_cpus) && ($number_of_cpus > 1)) {
		# $ENV{'HARNESS_OPTIONS'} = "j$number_of_cpus";
		# $ENV{'TEST_JOBS'} = $number_of_cpus;
	# }
# }
# };

my $number_of_cpus = Unix::Processors->new()->max_physical();
if(defined($number_of_cpus) && ($number_of_cpus > 1)) {
	$ENV{'HARNESS_OPTIONS'} = "j$number_of_cpus";
	$ENV{'TEST_JOBS'} = $number_of_cpus;
}

my @dists;

if($ARGV[0]) {
	require CPAN::Recent::Uploads;

	@dists = CPAN::Recent::Uploads->recent($ARGV[0] * 60, @{$CPAN::Config->{'urllist'}}[0]);
} else {
	foreach my $dist(split(/\n/, $recent)) {
		if($dist =~ /^authors\/id\/(.+)/) {
			$dist = $1;
		} else {
			next;
		}
		next if($dist =~ /\/CHECKSUMS$/);
		next if($dist =~ /\.meta$/);
		next if($dist =~ /\.readme$/);
		# $dist =~ s/\//::/g;

		push @dists, $dist;
	}
}

my $lock;
my $count = 0;
my $logfile = File::Spec->catfile(File::Spec->tmpdir(), basename($0));

while(1) {
	# my @load = Sys::LoadAvg::loadavg();
	# if($load[LOADAVG_1MIN] >= 3) {
		# print STDERR 'Busy - Load Average ', $load[LOADAVG_1MIN], "\n";

	my @lav = Sys::CpuLoad::load();
	if(defined($lav[0]) && ($lav[0] > 3)) {
		print STDERR 'Busy - Load Average ', $lav[0], "\n";
		sleep 120;
		next;
	}

	if((-r $lockfile) && (open($lock, '<', $lockfile))) {
		my $pid = <$lock>;
		close $lock;
		chomp $pid;
		if(kill(0, $pid)) {
			if(++$count >= 6) {
				die "Already running";
			}
			print "Already running\n" if($opts{'v'});
			sleep(10);
			next;
		}
	}
	open($lock, '>', $lockfile) or die "$lockfile: $!";
	flock($lock, LOCK_EX|LOCK_NB) or die "$lockfile: $!";
	print $lock $$;
	$lock->flush();
	last;
}


if(scalar(@dists)) {
	my $list;
	foreach my $dist(@dists) {
		next if($dist =~ /\/perl-5\./);
		if($list) {
			$list .= ',';
		}
		$list .= "\"\\\"$dist\\\"\"";
	}
	if($opts{'i'}) {
		# system("perl -MCPAN -e 'CPAN::Shell->test($list)'");
		system("testwrapper $list");
	} else {
		print join("\n", @dists), "\n";
		if($mode eq 'govern') {
			close(STDIN);
			open(STDIN, '<', '/dev/null');
			timed_system(3300, "testwrapper $list");
		} else {
			# timed_system(3300, "perl -MCPAN -e 'CPAN::Shell->test($list)' >> $logfile.out 2>> $logfile.err < /dev/null");
			timed_system(3300, "testwrapper $list >> $logfile.out 2>> $logfile.err < /dev/null");
		}
	}
}
close $lock if(defined($lock));
unlink $lockfile;

if($mode) {
	1 while(waitpid(-1, WNOHANG) >= 0);
}

# http://www.perlmonks.org/?node_id=324176
sub timed_system {
	my $timeout = shift;
	my @command;

	if($mode eq 'govern') {
		@command = ('bash', '-c', shift);
		my %args = (
			name => 'testwrapper',
			command => \@command,
			timeout => $timeout,
		);

		if($opts{'v'} || $opts{'i'}) {
			$args{show_stdout} = 1;
			$args{show_stderr} = 1;
			$args{log_stderr}->{'dir'} = File::Spec->tmpdir();
			$args{log_stderr}->{'size'} = '1M';
			$args{log_stderr}->{'histories'} = '100';
		} else {
			$args{show_stdout} = 0;
			$args{show_stderr} = 0;
		}

		return Proc::Govern::govern_process(%args);
	}

	my $command = join(' ', @_);

	if($mode eq 'killfam') {
		my $pid;

		my $rc = -1;
		eval {
			$pid = fork;

			die "Fork failed: $!" unless defined $pid;

			unless ($pid) {
				print "$command\n" if($opts{'v'});
				exec $command;
				die "Exec failed: $!";
			}

			local $SIG{ALRM} = sub {
				if($opts{'v'}) {
					print "Killing process family $pid\n";
				}
				Proc::Killfam::killfam(14, $pid);
				sleep 2;
				Proc::Killfam::killfam(15, $pid);
				sleep 2;
				Proc::Killfam::killfam(9, $pid);
				sleep 2;
				kill 14, $pid;
				sleep 2;
				kill 15, $pid;
				sleep 2;
				kill 9, $pid;

				if(kill(0, $pid)) {
					# syslog 'warn', "$pid won't die";
					die "$pid Won't die";
				}
				# die "Timeout!"

				1 while(waitpid(-1, WNOHANG) >= 0);
			}; # Just SIGTERM.

			alarm $timeout;

			$rc = (waitpid($pid, 0) == $pid) ? $? : -1;

			alarm 0;

			Proc::Killfam::killfam(14, $pid);
			sleep 2;
			Proc::Killfam::killfam(15, $pid);
			sleep 2;
			Proc::Killfam::killfam(9, $pid);
		};
		return -1 if $@ && $@ !~ /^Timeout!/;

		return $rc;
	}

	@command = ('bash', '-c', $command);
	return IPC::Cmd::run(command => \@command, timeout => $timeout, verbose => $opts{'v'});
}
