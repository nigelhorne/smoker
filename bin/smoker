#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2015-2019, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# I Love App::SmokeBox::Mini, unfortunately too many of its dependancies don't
# build on many platforms, so this is a small plaything that does for me

# Takes an optional argument of the number of minutes since the last run

# -v: verbose (logs more of what's going on)
# -d: debug (logs go to the console instead of /tmp/smoker.out and /tmp/smoker.err

# TODO:  $HOME/.cpan_smoker.rc doesn't get pruned.  Should remove entries older
#	than a week, for example

# 19 * * * * [ -r .perlbrew/init ] && /bin/bash bin/perlbrew-cron bin/smoker 60

use warnings;
use strict;
# use autodie qw(:all);	# Don't enable, since the kill failing isn't caught

use Getopt::Std;
use LWP::Simple;
use File::HomeDir;
use File::Path;
use File::Spec;
use File::Basename;
use FindBin qw($Bin);
use Fcntl qw(:flock);
use BSD::Resource;
use Unix::Processors;
# use Sys::LoadAvg;	# Core dumps because the array isn't big enough. Bug report has been ignored
use Sys::CpuLoad;
use Sys::Syslog;
use POSIX ":sys_wait_h";
use IO::Handle;
use IPC::Cmd;
use Config;
use JSON;

my $ppf_is_installed = 0;
if(eval { require Proc::PID::File; } ) {
	Proc::Pid::File->import();
	$ppf_is_installed = 1;
}

use lib File::Spec->catfile(File::HomeDir->my_home(), '/.cpan/CPAN');
use MyConfig;

die 'Install and configure CPAN::Reporter' unless($CPAN::Config->{'test_report'});
die unless($CPAN::Config->{'urllist'});

my $mode;

# Work out the best way to run commands
# Generally Proc::Killfam is better to use since all children will be killed,
#	I'm not persuaded that happens with Proc::Govern
if(($Config{'osname'} eq 'solaris') || ($Config{'osname'} eq 'gnukfreebsd')) {
	# Work around /usr/lib being built with Sun's C compiler, so
	# less is available because of link handshake errors
	eval {
		# Needs Proc::ProcessTable which doesn't support DragonflyBSD
		require Proc::Killfam;
		Proc::Killfam->import();
		$mode = 'killfam';
	};
	if(!defined($mode)) {
		eval {
			# Doesn't needs at least Perl 5.10.0
			require Proc::Govern;
			Proc::Govern->import();
			$mode = 'govern';
		};
	}
	if(!defined($mode)) {
		require IPC::Cmd;
		IPC::Cmd->import();
		$mode = 'cmd';
	}
} elsif(defined($^V) && ($^V ge 'v5.10.1')) {
	# Doesn't needs at least Perl 5.10.1
	require Proc::Govern;
	Proc::Govern->import();
	$mode = 'govern';
} elsif($Config{'osname'} eq 'dragonfly') {
	require IPC::Cmd;
	IPC::Cmd->import();
	$mode = 'cmd';
} else {
	# Needs Proc::ProcessTable which doesn't support DragonflyBSD
	require Proc::Killfam;
	Proc::Killfam->import();
	$mode = 'killfam';
}

my %opts;
getopts('div', \%opts);

if($opts{'d'}) {
	$opts{'v'} = 1;
}

print "Mode: $mode\n" if($opts{'v'});

$ENV{'CPAN_SQLITE_NO_LOG_FILES'} = 1;
delete $ENV{'CC'};
delete $ENV{'CFLAGS'};
delete $ENV{'LDFLAGS'};
if(!$opts{'i'}) {
	$ENV{'AUTOMATED_TESTING'} = 1;
}

openlog('CPAN', 'cons,pid', 'user');

my $lockfile = File::Spec->catfile($CPAN::Config->{'cpan_home'}, '.lock');
if((-r $lockfile) && (open(my $fin, '<', $lockfile))) {
	my $pid = <$fin>;
	close $fin;
	chomp $pid;
	if(kill(0, $pid)) {
		print STDERR "CPAN shell running\n";
		exit(1);
	}
	unlink $lockfile;
}

my $lock;
if($ppf_is_installed) {
	$lock = Proc::PID::File->new(dir => File::Spec->tmpdir(), name => 'cpan-test.lck', verify => 1);
} else {
	$lockfile = File::Spec->catfile(File::Spec->tmpdir(), 'cpan-test.lck.pid');
}

local $SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub {
	if($ppf_is_installed) {
		$lock->release();
	} elsif(-e $lockfile) {
		unlink($lockfile);
	}
	exit(1);
};

# Limit resources unless you're in a container,
#	in which case the container call should do it
#	e.g. 'docker run -m 1g'
# This doesn't work on Cygwin
if(($Config{'osname'} ne 'cygwin') && !(-r '/proc/1/cgroup')) {
	setrlimit(RLIMIT_DATA, 256 * 1024 * 1024, 512 * 1024 * 1024) or
		warn('Can\'t limit the data size - watch for memory usage');

	if($Config{'osname'} ne 'solaris') {
		setrlimit(RLIMIT_RSS, 32 * 1024 * 1024, 64 * 1024 * 1024) or
			warn('Can\'t limit the data size - watch for memory usage');
	}

	setrlimit(RLIMIT_CPU, 3300, 3600) or
		warn('Can\'t limit the CPU time - watch for long running programs');
}

# Eval added to handle RT113898
# eval {
	# my $number_of_cpus = Sys::Info->new()->device('CPU')->count();
#
	# if(defined($number_of_cpus) && ($number_of_cpus > 1)) {
		# $ENV{'HARNESS_OPTIONS'} = "j$number_of_cpus";
		# $ENV{'TEST_JOBS'} = $number_of_cpus;
	# }
# }
# };

my $number_of_cpus = Unix::Processors->new()->max_physical();
if(defined($number_of_cpus) && ($number_of_cpus > 1)) {
	$ENV{'HARNESS_OPTIONS'} = "j$number_of_cpus";
	$ENV{'TEST_JOBS'} = $number_of_cpus;
}

my @dists;
my $prev_tests;

my $json_file = File::Spec->catfile(File::HomeDir->my_home(), '/.cpan_smoker.rc');
if((-e $json_file) && open(my $fin, '<', $json_file)) {
	my $json = JSON->new()->allow_nonref();
	local $/ = undef;
	eval {
		$prev_tests = $json->decode(<$fin>);
	};
	close $fin;
}

if($ARGV[0]) {
	require CPAN::Recent::Uploads;

	@dists = CPAN::Recent::Uploads->recent($ARGV[0] * 60, @{$CPAN::Config->{'urllist'}}[0]);
} else {
	my $recent;
	foreach my $url(@{$CPAN::Config->{'urllist'}}) {
		if($recent = get("$url/RECENT")) {
			print "Fetching from $url\n" if($opts{'v'});
			last;
		}
	}

	die "Can't retrieve the RECENT file" if(!$recent);

	my $lastdist;
	my $now = time;

	foreach my $dist(reverse sort split(/\n/, $recent)) {
		if($dist =~ /^authors\/id\/(.+)/) {
			$dist = $1;
		} else {
			next;
		}
		next if($dist =~ /\/CHECKSUMS$/i);
		next if($dist =~ /\.meta$/i);
		next if($dist =~ /\.readme$/i);
		next if($dist =~ /\.html$/i);

		print "Considering $dist\n" if($opts{'v'});

		# Don't test earlier versions
		if($dist =~ /^([A-Z0-9\-\/]+)[v\-\.]\d+/i) {
			my $module = $1;
			if($lastdist) {
				# Ignore earlier version
				# print "-$dist\n";
				next if($module eq $lastdist);
			}
			$lastdist = $module;
		}
		# $dist =~ s/\//::/g;

		# Don't test versions already tested
		if(my $then = $prev_tests->{$^X}->{$dist}) {
			print "now: $now; then: $then\n" if($opts{'v'});
			if(($now - $then) > 7 * 24 * 3600) {
				# Prune the tree of old results
				print "Prune $dist from history\n" if($opts{'v'});
				delete $prev_tests->{$^X}->{$dist};
			}
		} else {
			# It's a new version
			unshift @dists, $dist;
			print "Will test $dist\n" if($opts{'v'});
		}
	}
}

if(scalar(@dists) == 0) {	# Won't write the pruned tree
	print "Nothing to smoke\n" if($opts{'v'});
	exit(0);
}

my $count = 0;
my $logfile = File::Spec->catfile(File::Spec->tmpdir(), basename($0));

while(1) {
	# my @load = Sys::LoadAvg::loadavg();
	# if($load[LOADAVG_1MIN] >= 3) {
		# print STDERR 'Busy - Load Average ', $load[LOADAVG_1MIN], "\n";

	if($Config{'osname'} ne 'cygwin') {
		# I don't know what Cygwin's load average is calculated from
		# so I don't trust it
		my @lav = Sys::CpuLoad::load();
		if(defined($lav[0])) {
			if($lav[0] > 5) {
				print STDERR 'Very Busy - Load Average ', $lav[0], "\n";
				exit(0);
			}
			if($lav[0] > 3) {
				print STDERR 'Busy - Load Average ', $lav[0], "\n";
				sleep(120);
				next;
			}
		}
	}

	if($ppf_is_installed) {
		while($lock->alive()) {
			if(++$count >= 6) {
				die "Already running" if($opts{'v'});
				exit(0);
			}
			print "Already running\n" if($opts{'v'});
			sleep(10);
		}
		$lock->touch();
	} elsif((-r $lockfile) && ($lock || open($lock, '<', $lockfile))) {
		my $pid = <$lock>;
		close $lock;
		if($pid) {
			chomp $pid;
			if(kill(0, $pid)) {
				if(++$count >= 6) {
					die "Already running" if($opts{'v'});
					exit(0);
				}
				print "Already running\n" if($opts{'v'});
				$lock = undef;
				sleep(10);
				next;
			}
		}
		open($lock, '>', $lockfile) or die "$lockfile: $!";
		flock($lock, LOCK_EX|LOCK_NB) or die "$lockfile: $!";
		print $lock $$;
		$lock->flush();
	}
	last;
}

# if(my $build_dir = $CPAN::Config->{'build_dir'}) {
	# File::Path::rmtree($build_dir);
# }

my $list;
foreach my $dist(@dists) {
	next if($dist =~ /\/perl-?[56][\.\/]/i);
	if($list) {
		$list .= ',';
	}
	$list .= "\"\\\"$dist\\\"\"";
	print "$dist\n";
}
# print join("\n", @dists), "\n";
if($opts{'i'}) {
	# system("perl -MCPAN -e 'CPAN::Shell->test($list)'");
	if($opts{'v'}) {
		my $shell = $ENV{'SHELL'} || $CPAN::Config->{'shell'} || 'bash';
		system("$shell -x $Bin/testwrapper $list");
	} else {
		system("$Bin/testwrapper $list");
	}
} else {
	if($mode eq 'govern') {
		close(STDIN);
		open(STDIN, '<', '/dev/null');
		unless($opts{'d'}) {
			close(STDOUT);
			open(STDOUT, '>>', "$logfile.out");
			close(STDERR);
			open(STDERR, '>>', "$logfile.err");
		}
		timed_system(3300, "$Bin/testwrapper $list");
	} elsif($opts{'d'}) {
		timed_system(3300, "$Bin/testwrapper $list < /dev/null");
	} else {
		# timed_system(3300, "perl -MCPAN -e 'CPAN::Shell->test($list)' >> $logfile.out 2>> $logfile.err < /dev/null");
		timed_system(3300, "$Bin/testwrapper $list >> $logfile.out 2>> $logfile.err < /dev/null");
	}
}

my $now = time;
foreach my $dist(@dists) {
	$prev_tests->{$^X}->{$dist} = $now;
}

unlink $json_file if(-e $json_file);

if(open(my $fout, '>', $json_file)) {
	print $fout JSON->new()->allow_nonref()->encode($prev_tests);
	close $fout;
}

if($mode) {
	nohang();
}

if($ppf_is_installed) {
	$lock->release();
} else {
	close $lock if(defined($lock));
	unlink($lockfile) if(-e $lockfile);
}

# http://www.perlmonks.org/?node_id=324176
sub timed_system {
	my $timeout = shift;
	my @command;

	my $shell = $ENV{'SHELL'} || $CPAN::Config->{'shell'} || 'bash';

	if($mode eq 'govern') {
		@command = ($shell, '-c', @_);
		my %args = (
			name => 'testwrapper',
			command => \@command,
			timeout => $timeout,
			killfam => 1,
			load_watch => 1,
			load_high_limit => $number_of_cpus + 1,
			load_low_limit => 1,
		);

		if($opts{'v'} || $opts{'i'}) {
			$args{show_stdout} = 1;
			$args{show_stderr} = 1;
			$args{log_stderr}->{'dir'} = File::Spec->tmpdir();
			$args{log_stderr}->{'size'} = '1M';
			$args{log_stderr}->{'histories'} = '100';
		} else {
			$args{show_stdout} = 0;
			$args{show_stderr} = 0;
		}

		return Proc::Govern::govern_process(%args);
	}

	my $command = join(' ', @_);

	if($mode eq 'killfam') {
		my $pid;

		my $rc = -1;
		eval {
			$pid = fork;

			die "Fork failed: $!" unless defined $pid;

			unless ($pid) {
				print "$command\n" if($opts{'v'});
				exec $command;
				die "Exec failed: $!";
			}

			local $SIG{ALRM} = sub {
				if($opts{'v'}) {
					print "Killing process family $pid\n";
				}
				my @pidlist = ($pid);
				Proc::Killfam::killfam(14, @pidlist);
				sleep 2;
				Proc::Killfam::killfam(15, @pidlist);
				sleep 2;
				Proc::Killfam::killfam(9, @pidlist);
				sleep 2;
				kill 14, $pid;
				sleep 2;
				kill 15, $pid;
				sleep 2;
				kill 9, $pid;
				sleep 2;

				if(kill(0, $pid)) {
					syslog 'warn', "$pid won't die";
					die "Timeout! $pid Won't die";
				}
				# die "Timeout!"

				nohang();
			}; # Just SIGTERM.

			alarm $timeout;

			$rc = (waitpid($pid, 0) == $pid) ? $? : -1;

			alarm 0;

			if(kill(0, $pid)) {
				my @pidlist = ($pid);
				Proc::Killfam::killfam(14, @pidlist);
				sleep 2;
				Proc::Killfam::killfam(15, @pidlist);
				sleep 2;
				Proc::Killfam::killfam(9, @pidlist);
				sleep 2;
				kill 9, $pid;
			}
		};
		return -1 if $@ && $@ !~ /^Timeout!/;

		return $rc;
	}

	if($opts{'v'}) {
		@command = ($shell, '-xc', $command);
	} else {
		@command = ($shell, '-c', $command);
	}
	return IPC::Cmd::run(command => \@command, timeout => $timeout, verbose => $opts{'v'});
}

sub nohang {
	my $count = 0;

	while(waitpid(-1, WNOHANG) >= 0) {
		if($count++ >= 60) {
			syslog('warning', 'Stopped waiting for child after 60 seconds');
			last;
		}
		sleep(1);
	}
}
