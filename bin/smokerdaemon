#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2016-2018, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# The local minicpan repository has been updated, test all of the updated
#	modules;
#
#	-v: verbose
#	-d: debugging

use warnings;
use strict;
use autodie qw(:all);

use IO::Socket::INET;
use File::HomeDir;
use File::Path;
use File::Spec;
use File::Basename;
use Sys::Syslog;
use File::Temp;
use Unix::Processors;
use Sys::CpuLoad;
use Proc::Killfam;
use Fcntl qw(:flock);
use Getopt::Std;
use POSIX ":sys_wait_h";
use BSD::Resource;

my $ppf_is_installed = 0;
if(eval { require Proc::PID::File; } ) {
	Proc::Pid::File->import();
	$ppf_is_installed = 1;
}

use lib File::Spec->catfile(File::HomeDir->my_home(), '/.cpan/CPAN');
use MyConfig;

die 'Install and configure CPAN::Reporter' unless($CPAN::Config->{'test_report'});

my $lockfile = File::Spec->catfile($CPAN::Config->{'cpan_home'}, '.lock');
if(-r $lockfile && (open(my $fin, '<', $lockfile))) {
	my $pid = <$fin>;
	close $fin;
	chomp $pid;
	if(kill(0, $pid)) {
		die "CPAN shell running\n";
	}
	unlink $lockfile;
}

my $lock;
if($ppf_is_installed) {
	$lock = Proc::PID::File->new(dir => File::Spec->tmpdir(), name => 'cpan-test.lck', verify => 1);
} else {
	$lockfile = File::Spec->catfile(File::Spec->tmpdir(), 'cpan-test.lck.pid');
}

my %opts;
getopts('dv', \%opts);

$opts{'v'} = 1 if($opts{'d'});

local $SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub {
	if($ppf_is_installed) {
		# FIXME:  causes unlink error in P:P:F if we're not currently running
		$lock->release();
	} else {
		unlink $lockfile;
	}
	exit 1;
};

# FIXME - should be argument
my $port = 21212;

$ENV{'CPAN_SQLITE_NO_LOG_FILES'} = 1;
delete $ENV{'CC'};
delete $ENV{'CFLAGS'};
delete $ENV{'LDFLAGS'};
$ENV{'AUTOMATED_TESTING'} = 1;

# TODO: read from config files
$ENV{'PERLBREW_ROOT'} = $ENV{'HOME'} . '/perl5/perlbrew';
$ENV{'PERLBREW_HOME'} = $ENV{'HOME'} . '/.perlbrew';

openlog 'CPAN', 'cons,pid', 'user';

if($^O ne 'cygwin') {
	setrlimit(RLIMIT_DATA, 128 * 1024 * 1024, 256 * 1024 * 1024) or
		warn ('Can\'t limit the data size - watch for memory usage');

	setrlimit(RLIMIT_RSS, 128 * 1024 * 1024, 256 * 1024 * 1024) or
		warn ('Can\'t limit the data size - watch for memory usage');
}

# Give 5 minutes to tidyup before the next hourly cron job starts
setrlimit(RLIMIT_CPU, 3300, 3600) or
	warn ('Can\'t limit the CPU time - watch for long running programs');

# Eval added to handle RT113898
# eval {
	# my $number_of_cpus = Sys::Info->new()->device('CPU')->count();
#
	# if(defined($number_of_cpus) && ($number_of_cpus > 1)) {
		# $ENV{'HARNESS_OPTIONS'} = "j$number_of_cpus";
		# $ENV{'TEST_JOBS'} = $number_of_cpus;
	# }
# }
# };

my $number_of_cpus = Unix::Processors->new()->max_physical();
if(defined($number_of_cpus) && ($number_of_cpus > 1)) {
	$ENV{'HARNESS_OPTIONS'} = "j$number_of_cpus";
	$ENV{'TEST_JOBS'} = $number_of_cpus;
}

my $logfile = File::Spec->catfile(File::Spec->tmpdir(), basename("$0.log"));

while(1) {
	# Not needed, but somehow it seems cleaner to close and reopen
	my $s = IO::Socket::INET->new(LocalPort => $port, Proto => 'udp')
		or die "Can't listen on port $port";

	my @dists;

	syslog 'info', 'Waiting to be told what to smoke';
	print "Waiting to be told what to smoke\n" if($opts{'v'});

	# push @dists, 'M/MI/MILSO/Pod-Weaver-Section-CommentString-0.03';
	DIST: while(1) {
		my $dist;

		$s->recv($dist, 256);

		chomp $dist;

		last DIST if($dist eq '');

		push @dists, $dist;
	}

	my $list;
	my $lastdist;

	foreach my $dist(reverse sort @dists) {
		# Don't test earlier versions
		if($dist =~ /^([A-Z0-9\-\/]+)[v\-\.]\d+/i) {
			my $module = $1;
			if($lastdist) {
				# Ignore earlier version
				# print "-$dist\n";
				next if($module eq $lastdist);
			}
			$lastdist = $module;
		}
		if($list) {
			$list .= ',';
		}
		$list .= "\\\"$dist.tar.gz\\\"";
	}

	if(!defined($list)) {
		sleep(1);	# avoid looping
		next;
	}

	syslog 'info', "Smoking $list";
	print 'Smoking ', join("\n", @dists), "\n";

	while(1) {
		my @lav = Sys::CpuLoad::load();
		if($lav[0] > 3) {
			sleep(10);
			next;
		}

		if($ppf_is_installed) {
			while($lock->alive()) {
				print "Already running\n" if($opts{'v'});
				sleep(10);
			}
			$lock->touch();
		} elsif((-r $lockfile) && open($lock, '<', $lockfile)) {
			my $pid = <$lock>;
			close $lock;
			if($pid) {
				chomp $pid;
				if(kill(0, $pid)) {
					print "Already running\n" if($opts{'v'});
					sleep(10);
					next;
				}
			}
			open($lock, '>', $lockfile) or die "$lockfile: $!";
			flock($lock, LOCK_EX|LOCK_NB) or die "$lockfile: $!";
			print $lock $$;
			$lock->flush();
		}
		last;
	}

	my $tmp = File::Temp->new(UNLINK => 0);
	if($opts{'v'}) {
		# print $tmp "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec perl -MCPAN -e 'CPAN::Shell->test($list)' < /dev/null\n";
		# print "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec perl -MCPAN -e 'CPAN::Shell->test($list)' < /dev/null\n";
		print $tmp "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec testwrapper $list < /dev/null\n";
		print "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec testwrapper $list < /dev/null\n";
	} else {
		# print $tmp "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec perl -MCPAN -e 'CPAN::Shell->test($list)' > $logfile 2>&1 < /dev/null\n";
		print $tmp "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec testwrapper $list > $logfile 2>&1 < /dev/null\n";
	}
	my $filename = $tmp->filename();
	close $tmp;

	if($opts{'v'}) {
		my $rc = timed_system(3300, $CPAN::Config->{'shell'}, '-v', $filename);
	} else {
		my $rc = timed_system(3300, $CPAN::Config->{'shell'}, $filename);
	}

	unlink $filename unless($opts{'d'});

	1 while(waitpid(-1, WNOHANG) >= 0);

	# if(my $build_dir = $CPAN::Config->{'build_dir'}) {
		# File::Path::rmtree($build_dir);
	# }
	if($ppf_is_installed) {
		$lock->release();
	} else {
		close $lock if(defined($lock));
		unlink $lockfile if(-r $lockfile);
	}
}

$lock->release();
closelog;

# http://www.perlmonks.org/?node_id=324176
sub timed_system {
	my $time = shift;

	my $pid;

	my $rc = -1;
	eval {
		$pid = fork;

		die "Fork failed: $!" unless defined $pid;

		unless ($pid) {
			exec @_;
			die "Exec failed: $!";
		}

		local $SIG{ALRM} = sub {
			if($opts{'v'}) {
				print "Killing process family $pid\n";
			}
			syslog 'info', "killing process family $pid";
			killfam 14, $pid;
			sleep 2;
			kill 14, $pid;
			sleep 2;
			killfam 9, $pid;
			kill 9, $pid;
			if(kill(0, $pid)) {
				syslog 'warn', "$pid won't die";
				die "Timeout! $pid Won't die";
			}
			# die "Timeout!"

			1 while(waitpid(-1, WNOHANG) >= 0);
		};

		alarm $time;

		$rc = (waitpid($pid, 0) == $pid) ? $? : -1;

		alarm 0;
	};
	return -1 if $@ && $@ !~ /^Timeout!/;

	return $rc;
}
