#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2016-2019, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# The local minicpan repository has been updated, test all of the updated
#	modules;
#
#	-p: port (default 21212)
#	-d: debugging
#	-v: verbose

use warnings;
use strict;
use autodie qw(:all);

use IO::Socket::INET;
use File::HomeDir;
use File::Path;
use File::Spec;
use File::Basename;
use Sys::Syslog;
use File::Temp;
use FindBin qw($Bin);
use Unix::Processors;
use Sys::CpuLoad;
use Fcntl qw(:flock);
use Getopt::Std;
use POSIX ":sys_wait_h";
use Config;
use BSD::Resource;

my $ppf_is_installed = 0;
if(eval { require Proc::PID::File; } ) {
	Proc::Pid::File->import();
	$ppf_is_installed = 1;
}

use lib File::Spec->catfile(File::HomeDir->my_home(), '/.cpan/CPAN');
use MyConfig;

die 'Configure CPAN::Reporter' unless($CPAN::Config->{'test_report'});
die unless($CPAN::Config->{'urllist'});

my $mode;

# Work out the best way to run commands
# Generally Proc::Killfam is better to use since all children will be killed,
#	I'm not persuaded that happens with Proc::Govern
if(($Config{'osname'} eq 'solaris') ||
   ($Config{'osname'} eq 'cygwin') ||
   ($Config{'osname'} eq 'gnukfreebsd')) {
	# Work around /usr/lib being built with Sun's C compiler, so
	# less is available because of link handshake errors
	eval {
		# Needs Proc::ProcessTable which doesn't support DragonflyBSD
		require Proc::Killfam;
		Proc::Killfam->import();
		$mode = 'killfam';
	};
	if(!defined($mode)) {
		eval {
			# Doesn't needs at least Perl 5.10.0
			require Proc::Govern;
			Proc::Govern->import();
			require Proc::Killfam;
			Proc::Killfam->import();
			$mode = 'govern';
		};
	}
	if(!defined($mode)) {
		require IPC::Cmd;
		IPC::Cmd->import();
		$mode = 'cmd';
	}
} elsif(defined($^V) && ($^V ge 'v5.10.1')) {
	# Doesn't needs at least Perl 5.10.1
	require Proc::Govern;
	Proc::Govern->import();
	require Proc::Killfam;
	Proc::Killfam->import();
	$mode = 'govern';
} elsif(($Config{'osname'} eq 'dragonfly') || ($Config{'osname'} eq 'haiku')) {
	require IPC::Cmd;
	IPC::Cmd->import();
	$mode = 'cmd';
} else {
	# Needs Proc::ProcessTable which doesn't support DragonflyBSD
	require Proc::Killfam;
	Proc::Killfam->import();
	$mode = 'killfam';
}

my $lockfile = File::Spec->catfile($CPAN::Config->{'cpan_home'}, '.lock');
if(-r $lockfile && (open(my $fin, '<', $lockfile))) {
	my $pid = <$fin>;
	close $fin;
	if($pid) {
		chomp $pid;
		# Workaround for RT#86238
		if(($pid =~ /^\d+$/) && CORE::kill(0, $pid)) {
			die "CPAN shell running\n";
		}
	}
	unlink $lockfile;
}

my $lock;
if($ppf_is_installed) {
	$lock = Proc::PID::File->new(dir => File::Spec->tmpdir(), name => 'cpan-test.lck', verify => 1);
} else {
	$lockfile = File::Spec->catfile(File::Spec->tmpdir(), 'cpan-test.lck.pid');
}

my %opts;
getopts('dp:v', \%opts);

$opts{'v'} = 1 if($opts{'d'});

local $SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub {
	if($ppf_is_installed) {
		# FIXME:  causes unlink error in P:P:F if we're not currently running
		$lock->release();
	} else {
		unlink $lockfile;
	}
	exit 1;
};

# Eval added to handle RT113898
# eval {
	# my $number_of_cpus = Sys::Info->new()->device('CPU')->count();
#
	# if(defined($number_of_cpus) && ($number_of_cpus > 1)) {
		# $ENV{'HARNESS_OPTIONS'} = "j$number_of_cpus";
		# $ENV{'TEST_JOBS'} = $number_of_cpus;
	# }
# }
# };

my $number_of_cpus = Unix::Processors->new()->max_physical();
if(defined($number_of_cpus) && ($number_of_cpus > 1)) {
	$ENV{'HARNESS_OPTIONS'} = "j$number_of_cpus";
	$ENV{'TEST_JOBS'} = $number_of_cpus;
} else {
	delete $ENV{'HARNESS_OPTIONS'};
	delete $ENV{'TEST_JOBS'};
}

print "Mode: $mode\n" if($opts{'v'});

# On first startup run a few tests that we may have missed
if($opts{'v'}) {
	require Data::Dumper;
	Data::Dumper->import();
	my $rc = timed_system(300, 'perlbrew', 'exec', "$Bin/smoker", '-v');
} else {
	my $rc = timed_system(300, 'perlbrew', 'exec', "$Bin/smoker");
}

# FIXME - should be argument
my $port = $opts{'p'} || 21212;

$ENV{'CPAN_SQLITE_NO_LOG_FILES'} = 1;
delete $ENV{'CC'};
delete $ENV{'CFLAGS'};
delete $ENV{'LDFLAGS'};
$ENV{'AUTOMATED_TESTING'} = 1;

# TODO: read from config files
$ENV{'PERLBREW_ROOT'} = File::Spec->catfile($ENV{'HOME'}, 'perl5/perlbrew');
$ENV{'PERLBREW_HOME'} = File::Spec->catfile($ENV{'HOME'}, '.perlbrew');

openlog('CPAN', 'cons,pid', 'user');

# Limit resources unless you're in a container,
#	in which case the container call should do it
#	e.g. 'docker run -m 1g'
# This doesn't work on Cygwin
if(($^O ne 'cygwin') && !(-r '/proc/1/cgroup')) {
	setrlimit(RLIMIT_DATA, 128 * 1024 * 1024, 256 * 1024 * 1024) or
		warn('Can\'t limit the data size - watch for memory usage');

	if($^O ne 'solaris') {
		setrlimit(RLIMIT_RSS, 128 * 1024 * 1024, 256 * 1024 * 1024) or
			warn('Can\'t limit the data size - watch for memory usage');
	}

	# Give 5 minutes to tidyup before the next hourly cron job starts
	setrlimit(RLIMIT_CPU, 3300, 3600) or
		warn('Can\'t limit the CPU time - watch for long running programs');
}

my $logfile = File::Spec->catfile(File::Spec->tmpdir(), basename("$0.out"));
my $errfile = File::Spec->catfile(File::Spec->tmpdir(), basename("$0.err"));

while(1) {
	# Not needed, but somehow it seems cleaner to close and reopen
	my $s = IO::Socket::INET->new(LocalPort => $port, Proto => 'udp')
		# or die "Can't listen on port $port";
		or exit(0);

	my @dists;

	syslog('info', "Waiting to be told on port $port what to smoke");
	print "Waiting to be told on port $port what to smoke\n" if($opts{'v'});

	# push @dists, 'M/MI/MILSO/Pod-Weaver-Section-CommentString-0.03';
	DIST: while(1) {
		my $dist;

		$s->recv($dist, 256);

		if($dist eq "\n") {
			print "End of list\n" if($opts{'v'});
			last DIST;
		}

		print "queuing $dist" if($opts{'v'});

		chomp $dist;

		push @dists, $dist;
	}

	$s->close();

	my $list;
	my $lastdist;

	foreach my $dist(reverse sort @dists) {
		# Don't test earlier versions
		if($dist =~ /^([A-Z0-9\-\/]+)[v\-\.]\d+/i) {
			my $module = $1;
			if($lastdist) {
				# Ignore earlier version
				# print "-$dist\n";
				next if($module eq $lastdist);
			}
			$lastdist = $module;
		} else {
			print "$dist: didn't match regex\n" if($opts{'v'});
		}
		if($list) {
			$list .= ',';
		}
		$list .= "\\\"$dist.tar.gz\\\"";
	}

	if(!defined($list)) {
		print "Nothing to smoke\n" if($opts{'v'});
		sleep(1);	# avoid looping
		next;
	}

	syslog('info', "Smoking $list");
	print 'Smoking ', join("\n", @dists), "\n";

	while(1) {
		my @lav = Sys::CpuLoad::load();
		if(defined($lav[0]) && ($lav[0] > 3)) {
			sleep(10);
			next;
		}

		if($ppf_is_installed) {
			while($lock->alive()) {
				print "Already running\n" if($opts{'v'});
				sleep(10);
			}
			$lock->touch();
		} else {
			if((-r $lockfile) && open($lock, '<', $lockfile)) {
				my $pid = <$lock>;
				close $lock;
				if($pid) {
					chomp $pid;
					if(kill(0, $pid)) {
						print "Already running\n" if($opts{'v'});
						sleep(10);
						next;
					}
				}
			}
			open($lock, '>', $lockfile) or die "$lockfile: $!";
			flock($lock, LOCK_EX|LOCK_NB) or die "$lockfile: $!";
			print $lock $$;
			$lock->flush();
		}
		last;
	}

	my $tmp = File::Temp->new(UNLINK => 0);
	if($opts{'v'}) {
		# print $tmp "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec perl -MCPAN -e 'CPAN::Shell->test($list)' < /dev/null\n";
		# print "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec perl -MCPAN -e 'CPAN::Shell->test($list)' < /dev/null\n";
		print $tmp "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec $Bin/testwrapper $list < /dev/null\n";
		print "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec $Bin/testwrapper $list < /dev/null\n";
	} else {
		# print $tmp "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec perl -MCPAN -e 'CPAN::Shell->test($list)' > $logfile 2> $errfile < /dev/null\n";
		print $tmp "source \$PERLBREW_ROOT/etc/bashrc\nexec perlbrew exec $Bin/testwrapper $list > $logfile 2> $errfile < /dev/null\n";
	}
	my $filename = $tmp->filename();
	close $tmp;

	chmod 0700, $filename;
	my $rc = timed_system(3300, $filename);

	unless($opts{'d'}) {
		if(-r $filename) {
			unlink($filename);
		} else {
			syslog('warning', "$filename has disappeared");
			warn "$filename has disappeared";
		}
	}

	nohang();
	if(-r '/proc/1/cgroup') {
		# Running in a Docker container, so nothing should be living with us
		if(my $build_dir = $CPAN::Config->{'build_dir'}) {
			File::Path::rmtree($build_dir);
		}
	}
	if($ppf_is_installed) {
		$lock->release();
	} else {
		close $lock if(defined($lock));
		unlink $lockfile if(-r $lockfile);
	}
}

$lock->release();
closelog;

# http://www.perlmonks.org/?node_id=324176
sub timed_system {
	my $timeout = shift;
	my @command;

	my $shell = $ENV{'SHELL'} || $CPAN::Config->{'shell'} || 'bash';

	my $command = join(' ', @_);

	if($opts{'v'}) {
		@command = ($shell, '-xc', $command);
	} else {
		@command = ($shell, '-c', $command);
	}

	if($mode eq 'govern') {
		my %args = (
			name => 'testwrapper',
			command => \@command,
			timeout => $timeout,
			killfam => 1,
			load_watch => 1,
			load_high_limit => $number_of_cpus + 1,
			load_low_limit => 1,
		);

		print Data::Dumper->new([\%args])->Dump() if($opts{'v'});

		if($opts{'v'} || $opts{'i'}) {
			$args{show_stdout} = 1;
			$args{show_stderr} = 1;
			$args{log_stderr}->{'dir'} = File::Spec->tmpdir();
			# $args{log_stderr}->{'size'} = '1M';
			$args{log_stderr}->{'size'} = 1024 * 1024;
			$args{log_stderr}->{'histories'} = '100';
		} else {
			$args{show_stdout} = 0;
			$args{show_stderr} = 0;
		}

		return Proc::Govern::govern_process(%args);
	}

	if($mode eq 'killfam') {
		my $pid;

		my $rc = -1;
		eval {
			$pid = fork;

			die "Fork failed: $!" unless defined $pid;

			unless ($pid) {
				if($opts{'v'}) {
					print "$shell -xc $command\n";
					exec $shell, '-xc', $command;
				} else {
					print "$shell -c $command\n";
					exec $shell, '-c', $command;
				}
				die "Exec failed: $!";
			}

			local $SIG{ALRM} = sub {
				if($opts{'v'}) {
					print "Killing process family $pid\n";
				}
				my @pidlist = ($pid);
				Proc::Killfam::killfam(14, @pidlist);
				sleep 2;
				Proc::Killfam::killfam(15, @pidlist);
				sleep 2;
				Proc::Killfam::killfam(9, @pidlist);
				sleep 2;
				kill 14, $pid;
				sleep 2;
				kill 15, $pid;
				sleep 2;
				kill 9, $pid;
				sleep 2;

				if(kill(0, $pid)) {
					syslog 'warn', "$pid won't die";
					die "Timeout! $pid Won't die";
				}
				# die "Timeout!"

				nohang();
			}; # Just SIGTERM.

			alarm $timeout;

			$rc = (waitpid($pid, 0) == $pid) ? $? : -1;

			alarm 0;

			if(kill(0, $pid)) {
				my @pidlist = ($pid);
				Proc::Killfam::killfam(14, @pidlist);
				sleep 2;
				Proc::Killfam::killfam(15, @pidlist);
				sleep 2;
				Proc::Killfam::killfam(9, @pidlist);
				sleep 2;
				kill 9, $pid;
			}
		};
		return -1 if $@ && $@ !~ /^Timeout!/;

		return $rc;
	}
	return IPC::Cmd::run(command => \@command, timeout => $timeout, verbose => $opts{'v'});
}

sub nohang {
	my $count = 0;

	while(waitpid(-1, WNOHANG) >= 0) {
		if($count++ >= 60) {
			syslog('warning', 'Stopped waiting for child after 60 seconds');
			last;
		}
		sleep(1);
	}
}
