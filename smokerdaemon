#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2016, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# The local minicpan repository has been updated, test all of the updated
#	modules;

use warnings;
use strict;

use IO::Socket::INET;
use File::HomeDir;
use File::Spec;
use Sys::Syslog;
use File::Temp;
use lib File::Spec->catfile(File::HomeDir->my_home(), '/.cpan/CPAN');
use MyConfig;
use Sys::Info;
use Sys::CpuLoad;

die unless($CPAN::Config->{'test_report'});

# FIXME - should be argument
my $port = 21212;

$ENV{'CPAN_SQLITE_NO_LOG_FILES'} = 1;
$ENV{'AUTOMATED_TESTING'} = 1;

# TODO: read from config files
$ENV{'PERLBREW_ROOT'} = $ENV{'HOME'} . '/perl5/perlbrew';
$ENV{'PERLBREW_HOME'} = $ENV{'HOME'} . '/.perlbrew';

openlog 'CPAN', 'cons,pid', 'user';

my $number_of_cpus = Sys::Info->new()->device('CPU')->count();

if($number_of_cpus > 1) {
	$ENV{'HARNESS_OPTIONS'} = "j$number_of_cpus";
	$ENV{'TEST_JOBS'} = $number_of_cpus;
}

while(1) {
	# Not needed, but somehow it seems cleaner to close and reopen
	my $s = IO::Socket::INET->new(LocalPort => $port, Proto => 'udp')
		or die "Can't listen on port $port";

	DIST: while(1) {
		my $dist;

		$s->recv($dist, 256);

		chomp $dist;

		last DIST if($dist eq '');

		while(1) {
			my @lav = Sys::CpuLoad::load();
			last if($lav[0] <= 3);
			sleep 10;
		}

		my $tmp = File::Temp->new(UNLINK => 0);
		print $tmp "source \$PERLBREW_ROOT/etc/bashrc\nperlbrew exec perl -MCPAN -e 'CPAN::Shell->test(\"$dist.tar.gz\")' > /dev/null 2>&1 < /dev/null\n";
		my $filename = $tmp->filename();
		close $tmp;

		my $rc = timed_system(300, $CPAN::Config->{'shell'} . " $filename");

		unlink $filename;

		syslog 'info', "$dist returned $rc";
		# print "$dist returned $rc";
	}
}
closelog;

# http://www.perlmonks.org/?node_id=324176
sub timed_system {
	my $time = shift;

	my $pid;
 
	local $SIG {ALRM} = sub {
		kill 15, $pid or die "kill: $!";
		# die "Timeout!"
	}; # Just SIGTERM.
 
	my $rc = -1;
	eval {
		$pid = fork;
 
		die "Fork failed: $!" unless defined $pid;
 
		unless ($pid) {
			exec @_;
			die "Exec failed: $!";
		}
 
		alarm $time;
 
		waitpid $pid => 0;

		$rc = $?;

		alarm 0;
	};
	return -1 if $@ && $@ !~ /^Timeout!/;

	return $rc;
}
